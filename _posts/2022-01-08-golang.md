---
title: Learning Golang from scratch
excerpt: 
last_modified_at: 2021-11-20
categories:
  - Golang
tags:
  - Golang
---

# Arrays
 In Go, assigning an array by value to another variable creates a duplicate of it. 
In particular, if you pass an array to a function, it will receive a copy of the array, not a pointer to it.
The size of an array is part of its type. The types [10]int and [20]int are distinct.

 https://www.pullrequest.com/blog/golang-vs-c-arrays/
 
# Slices

- A mix between a C array and a Python list.
- Arrays (fixed length) vs Slices (dynamic)
- An slice from an array is backed by the original array. Slice is just a few pointers.
- An slice has length and capacity.
- An slice cannot grow larger than its capacity. Slices can't access earlier elements of the original array (slice below zero)

Remember that make applies only to maps, slices and channels and does not return a pointer. To obtain an explicit pointer allocate with new or take the address of a variable explicitly.

## Useful funcions
- make to create a new slice
- copy like https://docs.oracle.com/javase/7/docs/api/java/lang/System.html#arraycopy(java.lang.Object,%20int,%20java.lang.Object,%20int,%20int)
- append grows the slice as needed
- to free memory used by original array, create a new slice and copy the data instead of just slicing the original array.

https://go.dev/blog/slices-intro


# Functions
- multiple returns
- named result parameters -> acts as doc.

```
func Names() (first string, second string) {
 first = "Foo"
 second = "Bar"
 return
}
```

# Defer

- Like finally but with advantages
- Deferred functions are executed in LIFO order
- arguments to deferred functions are evaluated when the defer executes


# Concurrency

## Gorutines
Goroutines and channels are one of the few places in the Go language where programmers can
introduce memory leaks.

Any function can be executed as a goroutine. And because Go allows you to declare
functions inline, you can share variables by declaring one function inside another and
closing over the variables you want to share.

## Semaphores
```
package main
import (
    "fmt"
    "time"
    "sync"
)

func main(){
    var wg sync.WaitGroup
    wg.Add(1)

    go func(){
        fmt.Println("Hello")
        time.Sleep(time.Millisecond * 100)
        wg.Done()
    }

    wg.Await()
}
```

## Channels
```
package main
import (
    "fmt"
    "time"
    "sync"
)

func main(){
    c := make(chan string)
    go func(c chan string){
        c <- "Hello"
        time.Sleep(time.Millisecond * 100)
    }

    msg := <- c
    fmt.Println(msg)
}
```

## Multiple messages

```
package main
import (
    "fmt"
    "time"
    "sync"
)

func main(){
    c := make(chan string)
    go func(c chan string){
        for i := 0 ; i < 5; i++ {
            c <- "Hello " + i
            time.Sleep(time.Millisecond * 100)
        }

        # sender can close the channel
        # receiver should never close the channel
        close(c)
    }()

    # receives messages until channel is closed
    for msg := range c{
        fmt.Println(msg)
    }
}
```

You can read from a channel and discard the value with
```
<- chanel
```

## Channel cleanup

Channels and goroutines can be leaked. They are not cleaned automatically because
runtime doesn't know when we stop using them.

The predominant method for avoiding unsafe channel closing is to use additional
channels to notify goroutines when it’s safe to close a channel.

The close function should be closed only by a sender, and in general it should be done with some protective guards around it.

Reading from a closed channel: A closed channel always returns the channel’s nil value.

## Channels as locks

Channel of size 1. Sending to the channel is acquring the lock and reading is releasing.
- If someone tries to acquire the lock (send a message) and the lock is already taken (channel size is 1 and there is 1 unread message), then sender will block
until there is space in the buffer (mesage is read, thus lock is released).

## Bufered channel

```
package main
import (
    "fmt"
    "time"
    "sync"
)

func main(){
    c := make(chan string, 2)
    c <- "Hello"

    msg := <- c
    fmt.Println(msg)

    msg := <- c
    fmt.Println(msg)
}
```

## Select

```
package main
import (
    "fmt"
    "time"
    "sync"
)

func main(){
    c1 := make(chan string )
    c2 := make(chan string)
    c <- "Hello"

    go func() {
        for {
            c1 <- "Fast"
            time.Slep(time.Milliseconds * 100)
        }
    }

    go func() {
        for {
            c2 <- "Slow"
            time.Slep(time.Seconds * 100)
        }
    }()    

    # Option 1
    for {
        fmt.Println( <- c1 )
        fmt.Println( <- c2 )
    }()

    # Option 2
    # Read available
    for {
        select {
            case msg1 := <- c1:
                fmt.Println(msg1)
            case msg2 := <- c2:
                fmt.Println(msg2)
        }
    }
    
}
```

## Multiple return values 

```
a := []string{"Foo", "Bar"}
for i, s := range a {
    fmt.Println(i, s)
}
```

Named return values https://go.dev/tour/basics/7
```
func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}
```
https://yourbasic.org/golang/gotcha-unexpected-values-range/
## Interfaces in Golang

Empty interface -> any
Interfaces are implicitly implemented. Duck typing at compile time
### Type assertion https://go.dev/tour/methods/15
instance of + cast alltogether
can also be used in a switch like java pattern matching https://www.infoq.com/articles/java-pattern-matching/

## Stringer
Stringer is toString() in Java
https://go.dev/tour/methods/17
Automatically called when printing the type.

## Errors
In idiomatic Go, the error is always the last return value.

 A function that returns an error is wrapped in an if/else statement
that checks whether the error value is something other than nil, and handles it if so
```
if result, err := Concat(args...); err != nil {
 fmt.Printf("Error: %s\n", err)
 } else {
 fmt.Printf("Concatenated string: '%s'\n", result)
 }
 ```

 Anything that has an Error function returning a string satisfies this Error interface’s contract

 ## Usage of nil
 When it makes sense, avail yourself of Go’s powerful multiple returns and send back
not just an error, but also a usable value.

The rule of thumb is that if a function can return a useful result when it
errs, then it should return one. But if it has nothing useful to return, it should send
back nil.

# Panic

An error indicates that an event occurred that might violate expectations about what
should have happened. A panic, in contrast, indicates that something has gone wrong
in such a way that the system (or the immediate subsystem) can’t continue to function.

An unhandled panic will kill your application.

https://www.toptal.com/back-end/server-side-io-performance-node-php-java-go
https://devhints.io/go
-> https://go.dev/doc/effective_go#names
-> https://stackoverflow.blog/2020/11/02/go-golang-learn-fast-programming-languages/

https://www.youtube.com/watch?v=LvgVSSpwND8&ab_channel=JakeWright
https://www.youtube.com/watch?v=VkGQFFl66X4&ab_channel=CodeWithRyan

Uber style guide https://github.com/uber-go/guide/blob/master/style.md
Common mistakes https://github.com/golang/go/wiki/CommonMistakes
https://github.com/golang/go/wiki/CodeReviewComments
